// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use crate::BaseInfo;
use crate::EnumInfo;
use crate::InterfaceInfo;
use crate::RepositoryLoadFlags;
use crate::Typelib;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;
use std::mem;
use std::ptr;

glib::wrapper! {
    /// [`Repository`][crate::Repository] is used to manage repositories of namespaces. Namespaces
    /// are represented on disk by type libraries (.typelib files).
    ///
    /// ### Discovery of type libraries
    ///
    /// [`Repository`][crate::Repository] will typically look for a `girepository-1.0` directory
    /// under the library directory used when compiling gobject-introspection.
    ///
    /// It is possible to control the search paths programmatically, using
    /// [`prepend_search_path()`][Self::prepend_search_path()]. It is also possible to modify
    /// the search paths by using the `GI_TYPELIB_PATH` environment variable.
    /// The environment variable takes precedence over the default search path
    /// and the [`prepend_search_path()`][Self::prepend_search_path()] calls.
    ///
    /// # Implements
    ///
    /// [`RepositoryExt`][trait@crate::prelude::RepositoryExt]
    #[doc(alias = "GIRepository")]
    pub struct Repository(Object<ffi::GIRepository, ffi::GIRepositoryClass>);

    match fn {
        type_ => || ffi::g_irepository_get_type(),
    }
}

impl Repository {
    pub const NONE: Option<&'static Repository> = None;

    #[doc(alias = "g_irepository_dump")]
    pub fn dump(arg: &str) -> Result<(), glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::g_irepository_dump(arg.to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "g_irepository_error_quark")]
    pub fn error_quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::g_irepository_error_quark()) }
    }

    /// Returns the singleton process-global default [`Repository`][crate::Repository]. It is
    /// not currently supported to have multiple repositories in a
    /// particular process, but this function is provided in the unlikely
    /// eventuality that it would become possible, and as a convenience for
    /// higher level language bindings to conform to the GObject method
    /// call conventions.
    ///
    /// All methods on [`Repository`][crate::Repository] also accept [`None`] as an instance
    /// parameter to mean this default repository, which is usually more
    /// convenient for C.
    ///
    /// # Returns
    ///
    /// The global singleton [`Repository`][crate::Repository]
    #[doc(alias = "g_irepository_get_default")]
    #[doc(alias = "get_default")]
    #[allow(clippy::should_implement_trait)]
    pub fn default() -> Option<Repository> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::g_irepository_get_default()) }
    }

    //#[doc(alias = "g_irepository_get_option_group")]
    //#[doc(alias = "get_option_group")]
    //pub fn option_group() -> /*Ignored*/Option<glib::OptionGroup> {
    //    unsafe { TODO: call ffi:g_irepository_get_option_group() }
    //}

    /// Returns the current search path [`Repository`][crate::Repository] will use when loading
    /// typelib files. The list is internal to [`Repository`][crate::Repository] and should not
    /// be freed, nor should its string elements.
    ///
    /// # Returns
    ///
    /// `GSList` of strings
    #[doc(alias = "g_irepository_get_search_path")]
    #[doc(alias = "get_search_path")]
    pub fn search_path() -> Vec<std::path::PathBuf> {
        assert_initialized_main_thread!();
        unsafe { FromGlibPtrContainer::from_glib_none(ffi::g_irepository_get_search_path()) }
    }

    #[doc(alias = "g_irepository_prepend_library_path")]
    pub fn prepend_library_path(directory: &str) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::g_irepository_prepend_library_path(directory.to_glib_none().0);
        }
    }

    /// Prepends `directory` to the typelib search path.
    ///
    /// See also: [`search_path()`][Self::search_path()].
    /// ## `directory`
    /// directory name to prepend to the typelib
    ///  search path
    #[doc(alias = "g_irepository_prepend_search_path")]
    pub fn prepend_search_path(directory: impl AsRef<std::path::Path>) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::g_irepository_prepend_search_path(directory.as_ref().to_glib_none().0);
        }
    }
}

/// Trait containing all [`struct@Repository`] methods.
///
/// # Implementors
///
/// [`Repository`][struct@crate::Repository]
pub trait RepositoryExt: 'static {
    /// Obtain an unordered list of versions (either currently loaded or
    /// available) for `namespace_` in this `self`.
    /// ## `namespace_`
    /// GI namespace, e.g. "Gtk"
    ///
    /// # Returns
    ///
    /// the array of versions.
    #[doc(alias = "g_irepository_enumerate_versions")]
    fn enumerate_versions(&self, namespace_: &str) -> Vec<glib::GString>;

    /// Searches for the enum type corresponding to the given [`glib::Error`][crate::glib::Error]
    /// domain. Before calling this function for a particular namespace,
    /// you must call [`require()`][Self::require()] once to load the namespace, or
    /// otherwise ensure the namespace has already been loaded.
    /// ## `domain`
    /// a [`glib::Error`][crate::glib::Error] domain
    ///
    /// # Returns
    ///
    /// `GIEnumInfo` representing metadata about `domain`'s
    /// enum type, or [`None`]
    #[doc(alias = "g_irepository_find_by_error_domain")]
    fn find_by_error_domain(&self, domain: glib::Quark) -> Option<EnumInfo>;

    /// Searches all loaded namespaces for a particular `GType`. Note that
    /// in order to locate the metadata, the namespace corresponding to
    /// the type must first have been loaded. There is currently no
    /// mechanism for determining the namespace which corresponds to an
    /// arbitrary GType - thus, this function will operate most reliably
    /// when you know the GType to originate from be from a loaded namespace.
    /// ## `gtype`
    /// GType to search for
    ///
    /// # Returns
    ///
    /// [`BaseInfo`][crate::BaseInfo] representing metadata about `type_`, or [`None`]
    #[doc(alias = "g_irepository_find_by_gtype")]
    fn find_by_gtype(&self, gtype: glib::types::Type) -> Option<BaseInfo>;

    /// Searches for a particular entry in a namespace. Before calling
    /// this function for a particular namespace, you must call
    /// [`require()`][Self::require()] once to load the namespace, or otherwise
    /// ensure the namespace has already been loaded.
    /// ## `namespace_`
    /// Namespace which will be searched
    /// ## `name`
    /// Entry name to find
    ///
    /// # Returns
    ///
    /// [`BaseInfo`][crate::BaseInfo] representing metadata about `name`, or [`None`]
    #[doc(alias = "g_irepository_find_by_name")]
    fn find_by_name(&self, namespace_: &str, name: &str) -> Option<BaseInfo>;

    /// This function returns the "C prefix", or the C level namespace
    /// associated with the given introspection namespace. Each C symbol
    /// starts with this prefix, as well each `GType` in the library.
    ///
    /// Note: The namespace must have already been loaded using a function
    /// such as [`require()`][Self::require()] before calling this function.
    /// ## `namespace_`
    /// Namespace to inspect
    ///
    /// # Returns
    ///
    /// C namespace prefix, or [`None`] if none associated
    #[doc(alias = "g_irepository_get_c_prefix")]
    #[doc(alias = "get_c_prefix")]
    fn c_prefix(&self, namespace_: &str) -> Option<glib::GString>;

    /// Retrieves all (transitive) versioned dependencies for
    /// `namespace_`.
    ///
    /// The strings are of the form `namespace-version`.
    ///
    /// Note: `namespace_` must have already been loaded using a function
    /// such as [`require()`][Self::require()] before calling this function.
    ///
    /// To get only the immediate dependencies for `namespace_`, use
    /// [`immediate_dependencies()`][Self::immediate_dependencies()].
    /// ## `namespace_`
    /// Namespace of interest
    ///
    /// # Returns
    ///
    /// all versioned
    ///  dependencies
    #[doc(alias = "g_irepository_get_dependencies")]
    #[doc(alias = "get_dependencies")]
    fn dependencies(&self, namespace_: &str) -> Vec<glib::GString>;

    /// Return an array of the immediate versioned dependencies for `namespace_`.
    /// Returned strings are of the form `namespace-version`.
    ///
    /// Note: `namespace_` must have already been loaded using a function
    /// such as [`require()`][Self::require()] before calling this function.
    ///
    /// To get the transitive closure of dependencies for `namespace_`, use
    /// [`dependencies()`][Self::dependencies()].
    /// ## `namespace_`
    /// Namespace of interest
    ///
    /// # Returns
    ///
    /// Zero-terminated string array of immediate versioned
    ///  dependencies
    #[doc(alias = "g_irepository_get_immediate_dependencies")]
    #[doc(alias = "get_immediate_dependencies")]
    fn immediate_dependencies(&self, namespace_: &str) -> Vec<glib::GString>;

    /// This function returns a particular metadata entry in the
    /// given namespace `namespace_`. The namespace must have
    /// already been loaded before calling this function.
    /// See [`n_infos()`][Self::n_infos()] to find the maximum number of
    /// entries.
    /// ## `namespace_`
    /// Namespace to inspect
    /// ## `index`
    /// 0-based offset into namespace metadata for entry
    ///
    /// # Returns
    ///
    /// [`BaseInfo`][crate::BaseInfo] containing metadata
    #[doc(alias = "g_irepository_get_info")]
    #[doc(alias = "get_info")]
    fn info(&self, namespace_: &str, index: i32) -> Option<BaseInfo>;

    /// Return the list of currently loaded namespaces.
    ///
    /// # Returns
    ///
    /// List of namespaces
    #[doc(alias = "g_irepository_get_loaded_namespaces")]
    #[doc(alias = "get_loaded_namespaces")]
    fn loaded_namespaces(&self) -> Vec<glib::GString>;

    /// This function returns the number of metadata entries in
    /// given namespace `namespace_`. The namespace must have
    /// already been loaded before calling this function.
    /// ## `namespace_`
    /// Namespace to inspect
    ///
    /// # Returns
    ///
    /// number of metadata entries
    #[doc(alias = "g_irepository_get_n_infos")]
    #[doc(alias = "get_n_infos")]
    fn n_infos(&self, namespace_: &str) -> i32;

    /// Look up the implemented interfaces for `gtype`. This function
    /// cannot fail per se; but for a totally "unknown" `GType`, it may
    /// return 0 implemented interfaces.
    ///
    /// The semantics of this function are designed for a dynamic binding,
    /// where in certain cases (such as a function which returns an
    /// interface which may have "hidden" implementation classes), not all
    /// data may be statically known, and will have to be determined from
    /// the `GType` of the object. An example is `g_file_new_for_path()`
    /// returning a concrete class of `GLocalFile`, which is a `GType` we
    /// see at runtime, but not statically.
    /// ## `gtype`
    /// a `GType` whose fundamental type is G_TYPE_OBJECT
    ///
    /// # Returns
    ///
    ///
    /// ## `interfaces_out`
    /// Interfaces for `gtype`
    #[doc(alias = "g_irepository_get_object_gtype_interfaces")]
    #[doc(alias = "get_object_gtype_interfaces")]
    fn object_gtype_interfaces(&self, gtype: glib::types::Type) -> Vec<InterfaceInfo>;

    /// This function returns a comma-separated list of paths to the
    /// shared C libraries associated with the given namespace `namespace_`.
    /// There may be no shared library path associated, in which case this
    /// function will return [`None`].
    ///
    /// Note: The namespace must have already been loaded using a function
    /// such as [`require()`][Self::require()] before calling this function.
    /// ## `namespace_`
    /// Namespace to inspect
    ///
    /// # Returns
    ///
    /// Comma-separated list of paths to shared libraries,
    ///  or [`None`] if none are associated
    #[doc(alias = "g_irepository_get_shared_library")]
    #[doc(alias = "get_shared_library")]
    fn shared_library(&self, namespace_: &str) -> Option<glib::GString>;

    /// If namespace `namespace_` is loaded, return the full path to the
    /// .typelib file it was loaded from. If the typelib for
    /// namespace `namespace_` was included in a shared library, return
    /// the special string "&lt;builtin&gt;".
    /// ## `namespace_`
    /// GI namespace to use, e.g. "Gtk"
    ///
    /// # Returns
    ///
    /// Filesystem path (or $lt;builtin$gt;) if successful, [`None`] if namespace is not loaded
    #[doc(alias = "g_irepository_get_typelib_path")]
    #[doc(alias = "get_typelib_path")]
    fn typelib_path(&self, namespace_: &str) -> Option<glib::GString>;

    /// This function returns the loaded version associated with the given
    /// namespace `namespace_`.
    ///
    /// Note: The namespace must have already been loaded using a function
    /// such as [`require()`][Self::require()] before calling this function.
    /// ## `namespace_`
    /// Namespace to inspect
    ///
    /// # Returns
    ///
    /// Loaded version
    #[doc(alias = "g_irepository_get_version")]
    #[doc(alias = "get_version")]
    fn version(&self, namespace_: &str) -> Option<glib::GString>;

    /// Check whether a particular namespace (and optionally, a specific
    /// version thereof) is currently loaded. This function is likely to
    /// only be useful in unusual circumstances; in order to act upon
    /// metadata in the namespace, you should call [`require()`][Self::require()]
    /// instead which will ensure the namespace is loaded, and return as
    /// quickly as this function will if it has already been loaded.
    /// ## `namespace_`
    /// Namespace of interest
    /// ## `version`
    /// Required version, may be [`None`] for latest
    ///
    /// # Returns
    ///
    /// [`true`] if namespace-version is loaded, [`false`] otherwise
    #[doc(alias = "g_irepository_is_registered")]
    fn is_registered(&self, namespace_: &str, version: Option<&str>) -> bool;

    /// TODO
    /// ## `typelib`
    /// TODO
    /// ## `flags`
    /// TODO
    #[doc(alias = "g_irepository_load_typelib")]
    fn load_typelib(
        &self,
        typelib: &mut Typelib,
        flags: RepositoryLoadFlags,
    ) -> Result<glib::GString, glib::Error>;

    /// Force the namespace `namespace_` to be loaded if it isn't already.
    /// If `namespace_` is not loaded, this function will search for a
    /// ".typelib" file using the repository search path. In addition, a
    /// version `version` of namespace may be specified. If `version` is
    /// not specified, the latest will be used.
    /// ## `namespace_`
    /// GI namespace to use, e.g. "Gtk"
    /// ## `version`
    /// Version of namespace, may be [`None`] for latest
    /// ## `flags`
    /// Set of `GIRepositoryLoadFlags`, may be 0
    ///
    /// # Returns
    ///
    /// a pointer to the [`Typelib`][crate::Typelib] if successful, [`None`] otherwise
    #[doc(alias = "g_irepository_require")]
    fn require(
        &self,
        namespace_: &str,
        version: Option<&str>,
        flags: RepositoryLoadFlags,
    ) -> Result<Typelib, glib::Error>;

    /// Force the namespace `namespace_` to be loaded if it isn't already.
    /// If `namespace_` is not loaded, this function will search for a
    /// ".typelib" file within the private directory only. In addition, a
    /// version `version` of namespace should be specified. If `version` is
    /// not specified, the latest will be used.
    /// ## `typelib_dir`
    /// Private directory where to find the requested typelib
    /// ## `namespace_`
    /// GI namespace to use, e.g. "Gtk"
    /// ## `version`
    /// Version of namespace, may be [`None`] for latest
    /// ## `flags`
    /// Set of `GIRepositoryLoadFlags`, may be 0
    ///
    /// # Returns
    ///
    /// a pointer to the [`Typelib`][crate::Typelib] if successful, [`None`] otherwise
    #[doc(alias = "g_irepository_require_private")]
    fn require_private(
        &self,
        typelib_dir: &str,
        namespace_: &str,
        version: Option<&str>,
        flags: RepositoryLoadFlags,
    ) -> Result<Typelib, glib::Error>;
}

impl<O: IsA<Repository>> RepositoryExt for O {
    fn enumerate_versions(&self, namespace_: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::g_irepository_enumerate_versions(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            ))
        }
    }

    fn find_by_error_domain(&self, domain: glib::Quark) -> Option<EnumInfo> {
        unsafe {
            from_glib_full(ffi::g_irepository_find_by_error_domain(
                self.as_ref().to_glib_none().0,
                domain.into_glib(),
            ))
        }
    }

    fn find_by_gtype(&self, gtype: glib::types::Type) -> Option<BaseInfo> {
        unsafe {
            from_glib_full(ffi::g_irepository_find_by_gtype(
                self.as_ref().to_glib_none().0,
                gtype.into_glib(),
            ))
        }
    }

    fn find_by_name(&self, namespace_: &str, name: &str) -> Option<BaseInfo> {
        unsafe {
            from_glib_full(ffi::g_irepository_find_by_name(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    fn c_prefix(&self, namespace_: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::g_irepository_get_c_prefix(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            ))
        }
    }

    fn dependencies(&self, namespace_: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::g_irepository_get_dependencies(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            ))
        }
    }

    fn immediate_dependencies(&self, namespace_: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::g_irepository_get_immediate_dependencies(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            ))
        }
    }

    fn info(&self, namespace_: &str, index: i32) -> Option<BaseInfo> {
        unsafe {
            from_glib_full(ffi::g_irepository_get_info(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
                index,
            ))
        }
    }

    fn loaded_namespaces(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::g_irepository_get_loaded_namespaces(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn n_infos(&self, namespace_: &str) -> i32 {
        unsafe {
            ffi::g_irepository_get_n_infos(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            )
        }
    }

    fn object_gtype_interfaces(&self, gtype: glib::types::Type) -> Vec<InterfaceInfo> {
        unsafe {
            let mut n_interfaces_out = mem::MaybeUninit::uninit();
            let mut interfaces_out = ptr::null_mut();
            ffi::g_irepository_get_object_gtype_interfaces(
                self.as_ref().to_glib_none().0,
                gtype.into_glib(),
                n_interfaces_out.as_mut_ptr(),
                &mut interfaces_out,
            );
            FromGlibContainer::from_glib_none_num(
                interfaces_out,
                n_interfaces_out.assume_init() as _,
            )
        }
    }

    fn shared_library(&self, namespace_: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::g_irepository_get_shared_library(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            ))
        }
    }

    fn typelib_path(&self, namespace_: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::g_irepository_get_typelib_path(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            ))
        }
    }

    fn version(&self, namespace_: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::g_irepository_get_version(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
            ))
        }
    }

    fn is_registered(&self, namespace_: &str, version: Option<&str>) -> bool {
        unsafe {
            from_glib(ffi::g_irepository_is_registered(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
                version.to_glib_none().0,
            ))
        }
    }

    fn load_typelib(
        &self,
        typelib: &mut Typelib,
        flags: RepositoryLoadFlags,
    ) -> Result<glib::GString, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::g_irepository_load_typelib(
                self.as_ref().to_glib_none().0,
                typelib.to_glib_none_mut().0,
                flags.into_glib(),
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_none(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn require(
        &self,
        namespace_: &str,
        version: Option<&str>,
        flags: RepositoryLoadFlags,
    ) -> Result<Typelib, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::g_irepository_require(
                self.as_ref().to_glib_none().0,
                namespace_.to_glib_none().0,
                version.to_glib_none().0,
                flags.into_glib(),
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_none(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn require_private(
        &self,
        typelib_dir: &str,
        namespace_: &str,
        version: Option<&str>,
        flags: RepositoryLoadFlags,
    ) -> Result<Typelib, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::g_irepository_require_private(
                self.as_ref().to_glib_none().0,
                typelib_dir.to_glib_none().0,
                namespace_.to_glib_none().0,
                version.to_glib_none().0,
                flags.into_glib(),
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_none(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }
}

impl fmt::Display for Repository {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Repository")
    }
}
